import React, { useState, useRef, useEffect, useCallback } from 'react';
import './CameraFeed.css';

const CameraFeed = () => {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const [currentStream, setCurrentStream] = useState(null);
  const [currentFacingMode, setCurrentFacingMode] = useState('user');
  const [status, setStatus] = useState({ message: '', type: 'info' });
  const [isProcessing, setIsProcessing] = useState(false);
  const [result, setResult] = useState(null);
  const [capturedImage, setCapturedImage] = useState(null);
  const [language, setLanguage] = useState('English');
  const [processingError, setProcessingError] = useState(null);
  const [processedResult, setProcessedResult] = useState(null);
  const [isResultVisible, setIsResultVisible] = useState(false);
  const [captureHistory, setCaptureHistory] = useState([]);
  const [currentCaptureData, setCurrentCaptureData] = useState(null);
  const [lightboxData, setLightboxData] = useState(null);
  const [ttsAudioUrl, setTtsAudioUrl] = useState(null);
  const [isTtsLoading, setIsTtsLoading] = useState(false);
  const [isTtsOn, setIsTtsOn] = useState(true);
  const [isGloballyMuted, setIsGloballyMuted] = useState(false);
  const audioRef = useRef(null);
  const resultContainerRef = useRef(null);

  const languageOptions = {
    'English': 'üá∫üá∏ English',
    'Spanish': 'üá™üá∏ Spanish',
    'French': 'üá´üá∑ French',
    'German': 'üá©üá™ German',
    'Italian': 'üáÆüáπ Italian',
    'Portuguese': 'üáµüáπ Portuguese',
    'Chinese': 'üá®üá≥ Chinese',
    'Japanese': 'üáØüáµ Japanese',
    'Korean': 'üá∞üá∑ Korean',
  };

  // Get translated labels based on selected language
  const getLabels = (lang) => {
    const labels = {
      'English': {
        text: 'Translation',
        description: 'Context',
        noText: 'No text detected in image',
        history: 'History',
        viewHistory: 'View History',
        accessingCamera: 'Accessing camera...',
        cameraReady: 'Camera ready!',
        cameraFailed: 'Camera access failed. ',
        allowCamera: 'Please allow camera access and try again.',
        noCamera: 'No camera found on this device.',
        notSupported: 'Camera not supported in this browser.',
        unknownError: 'Unknown error occurred.',
        switchingCamera: 'Switching camera...',
        analyzingImage: 'Analyzing image...',
        analysisComplete: 'Analysis complete!',
        connectionFailed: 'Connection failed. Check if server is running.',
        failedToProcess: 'Failed to process image',
        processingIndicator: 'Analyzing your image...',
        yourGlance: 'Your Glance',
        previousCaptures: 'Previous Views',
        clearAll: 'Clear All',
        deleteCaptureTitle: 'Delete this capture',
        back: 'Back',
        captureImageTitle: 'Capture Image',
        globalMute: 'Mute all sounds',
        globalUnmute: 'Unmute all sounds',
      },
      'Spanish': {
        text: 'Traducci√≥n',
        description: 'Contexto',
        noText: 'No se detect√≥ texto en la imagen',
        history: 'Historial',
        viewHistory: 'Ver Historial',
        accessingCamera: 'Accediendo a la c√°mara...',
        cameraReady: '¬°C√°mara lista!',
        cameraFailed: 'Fall√≥ el acceso a la c√°mara. ',
        allowCamera: 'Por favor, permite el acceso a la c√°mara e int√©ntalo de nuevo.',
        noCamera: 'No se encontr√≥ ninguna c√°mara en este dispositivo.',
        notSupported: 'La c√°mara no es compatible con este navegador.',
        unknownError: 'Ocurri√≥ un error desconocido.',
        switchingCamera: 'Cambiando de c√°mara...',
        analyzingImage: 'Analizando imagen...',
        analysisComplete: '¬°An√°lisis completo!',
        connectionFailed: 'Fall√≥ la conexi√≥n. Comprueba si el servidor est√° funcionando.',
        failedToProcess: 'Error al procesar la imagen',
        processingIndicator: 'Analizando tu imagen...',
        yourGlance: 'Tu Vistazo',
        previousCaptures: 'Vistas Anteriores',
        clearAll: 'Borrar Todo',
        deleteCaptureTitle: 'Eliminar esta captura',
        back: 'Atr√°s',
        captureImageTitle: 'Capturar Imagen',
        globalMute: 'Silenciar todos los sonidos',
        globalUnmute: 'Activar todos los sonidos',
      },
      'French': {
        text: 'Traduction',
        description: 'Contexte',
        noText: 'Aucun texte d√©tect√© dans l\'image',
        history: 'Historique',
        viewHistory: 'Voir l\'Historique',
        accessingCamera: 'Acc√®s √† la cam√©ra...',
        cameraReady: 'Cam√©ra pr√™te !',
        cameraFailed: 'L\'acc√®s √† la cam√©ra a √©chou√©. ',
        allowCamera: 'Veuillez autoriser l\'acc√®s √† la cam√©ra et r√©essayer.',
        noCamera: 'Aucune cam√©ra trouv√©e sur cet appareil.',
        notSupported: 'Cam√©ra non prise en charge par ce navigateur.',
        unknownError: 'Une erreur inconnue est survenue.',
        switchingCamera: 'Changement de cam√©ra...',
        analyzingImage: 'Analyse de l\'image...',
        analysisComplete: 'Analyse termin√©e !',
        connectionFailed: 'La connexion a √©chou√©. V√©rifiez si le serveur est en cours d\'ex√©cution.',
        failedToProcess: '√âchec du traitement de l\'image',
        processingIndicator: 'Analyse de votre image...',
        yourGlance: 'Votre Aper√ßu',
        previousCaptures: 'Vues Pr√©c√©dentes',
        clearAll: 'Tout Effacer',
        deleteCaptureTitle: 'Supprimer cette capture',
        back: 'Retour',
        captureImageTitle: 'Capturer une image',
        globalMute: 'D√©sactiver tous les sons',
        globalUnmute: 'Activer tous les sons',
      },
      'German': {
        text: '√úbersetzung',
        description: 'Kontext',
        noText: 'Kein Text im Bild erkannt',
        history: 'Verlauf',
        viewHistory: 'Verlauf anzeigen',
        accessingCamera: 'Greife auf Kamera zu...',
        cameraReady: 'Kamera bereit!',
        cameraFailed: 'Kamerazugriff fehlgeschlagen. ',
        allowCamera: 'Bitte erlauben Sie den Kamerazugriff und versuchen Sie es erneut.',
        noCamera: 'Keine Kamera auf diesem Ger√§t gefunden.',
        notSupported: 'Kamera wird in diesem Browser nicht unterst√ºtzt.',
        unknownError: 'Unbekannter Fehler aufgetreten.',
        switchingCamera: 'Wechsle Kamera...',
        analyzingImage: 'Analysiere Bild...',
        analysisComplete: 'Analyse abgeschlossen!',
        connectionFailed: 'Verbindung fehlgeschlagen. √úberpr√ºfen Sie, ob der Server l√§uft.',
        failedToProcess: 'Bildverarbeitung fehlgeschlagen',
        processingIndicator: 'Dein Bild wird analysiert...',
        yourGlance: 'Dein Blick',
        previousCaptures: 'Fr√ºhere Ansichten',
        clearAll: 'Alles L√∂schen',
        deleteCaptureTitle: 'Diese Aufnahme l√∂schen',
        back: 'Zur√ºck',
        captureImageTitle: 'Bild aufnehmen',
        globalMute: 'Alle T√∂ne stummschalten',
        globalUnmute: 'Alle T√∂ne einschalten',
      },
      'Italian': {
        text: 'Traduzione',
        description: 'Contesto',
        noText: 'Nessun testo rilevato nell\'immagine',
        history: 'Cronologia',
        viewHistory: 'Visualizza Cronologia',
        accessingCamera: 'Accesso alla fotocamera...',
        cameraReady: 'Fotocamera pronta!',
        cameraFailed: 'Accesso alla fotocamera non riuscito. ',
        allowCamera: 'Consenti l\'accesso alla fotocamera e riprova.',
        noCamera: 'Nessuna fotocamera trovata su questo dispositivo.',
        notSupported: 'Fotocamera non supportata in questo browser.',
        unknownError: 'Si √® verificato un errore sconosciuto.',
        switchingCamera: 'Cambio fotocamera...',
        analyzingImage: 'Analisi dell\'immagine...',
        analysisComplete: 'Analisi completata!',
        connectionFailed: 'Connessione non riuscita. Controlla se il server √® in esecuzione.',
        failedToProcess: 'Elaborazione dell\'immagine non riuscita',
        processingIndicator: 'Analisi della tua immagine...',
        yourGlance: 'Il Tuo Sguardo',
        previousCaptures: 'Visualizzazioni Precedenti',
        clearAll: 'Cancella Tutto',
        deleteCaptureTitle: 'Elimina questa cattura',
        back: 'Indietro',
        captureImageTitle: 'Cattura Immagine',
        globalMute: 'Disattiva tutti i suoni',
        globalUnmute: 'Attiva tutti i suoni',
      },
      'Portuguese': {
        text: 'Tradu√ß√£o',
        description: 'Contexto',
        noText: 'Nenhum texto detectado na imagem',
        history: 'Hist√≥rico',
        viewHistory: 'Ver Hist√≥rico',
        accessingCamera: 'Acessando a c√¢mera...',
        cameraReady: 'C√¢mera pronta!',
        cameraFailed: 'O acesso √† c√¢mera falhou. ',
        allowCamera: 'Permita o acesso √† c√¢mera e tente novamente.',
        noCamera: 'Nenhuma c√¢mera encontrada neste dispositivo.',
        notSupported: 'C√¢mera n√£o suportada neste navegador.',
        unknownError: 'Ocorreu um erro desconhecido.',
        switchingCamera: 'Trocando de c√¢mera...',
        analyzingImage: 'Analisando imagem...',
        analysisComplete: 'An√°lise conclu√≠da!',
        connectionFailed: 'A conex√£o falhou. Verifique se o servidor est√° em execu√ß√£o.',
        failedToProcess: 'Falha ao processar a imagem',
        processingIndicator: 'Analisando sua imagem...',
        yourGlance: 'Sua Olhada',
        previousCaptures: 'Visualiza√ß√µes Anteriores',
        clearAll: 'Limpar Tudo',
        deleteCaptureTitle: 'Excluir esta captura',
        back: 'Voltar',
        captureImageTitle: 'Capturar Imagem',
        globalMute: 'Silenciar todos os sons',
        globalUnmute: 'Ativar todos os sons',
      },
      'Chinese': {
        text: 'ÁøªËØë',
        description: '‰∏ä‰∏ãÊñá',
        noText: 'ÂõæÂÉè‰∏≠Êú™Ê£ÄÊµãÂà∞ÊñáÊú¨',
        history: 'ÂéÜÂè≤',
        viewHistory: 'Êü•ÁúãÂéÜÂè≤',
        accessingCamera: 'Ê≠£Âú®ËÆøÈóÆÊëÑÂÉèÂ§¥...',
        cameraReady: 'ÊëÑÂÉèÂ§¥ÂáÜÂ§áÂ∞±Áª™ÔºÅ',
        cameraFailed: 'ÊëÑÂÉèÂ§¥ËÆøÈóÆÂ§±Ë¥•„ÄÇ',
        allowCamera: 'ËØ∑ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ËÆøÈóÆÊùÉÈôêÂêéÈáçËØï„ÄÇ',
        noCamera: 'Ê≠§ËÆæÂ§á‰∏äÊú™ÊâæÂà∞ÊëÑÂÉèÂ§¥„ÄÇ',
        notSupported: 'Ê≠§ÊµèËßàÂô®‰∏çÊîØÊåÅÊëÑÂÉèÂ§¥„ÄÇ',
        unknownError: 'ÂèëÁîüÊú™Áü•ÈîôËØØ„ÄÇ',
        switchingCamera: 'Ê≠£Âú®ÂàáÊç¢ÊëÑÂÉèÂ§¥...',
        analyzingImage: 'Ê≠£Âú®ÂàÜÊûêÂõæÂÉè...',
        analysisComplete: 'ÂàÜÊûêÂÆåÊàêÔºÅ',
        connectionFailed: 'ËøûÊé•Â§±Ë¥•„ÄÇËØ∑Ê£ÄÊü•ÊúçÂä°Âô®ÊòØÂê¶Ê≠£Âú®ËøêË°å„ÄÇ',
        failedToProcess: 'ÂõæÂÉèÂ§ÑÁêÜÂ§±Ë¥•',
        processingIndicator: 'Ê≠£Âú®ÂàÜÊûêÊÇ®ÁöÑÂõæÂÉè...',
        yourGlance: 'ÊÇ®ÁöÑÂç≥ËßÜ',
        previousCaptures: 'ÂéÜÂè≤ËßÜËßí',
        clearAll: 'ÂÖ®ÈÉ®Ê∏ÖÈô§',
        deleteCaptureTitle: 'Âà†Èô§Ê≠§ÊçïËé∑',
        back: 'ËøîÂõû',
        captureImageTitle: 'ÊãçÊëÑÁÖßÁâá',
        globalMute: 'ÈùôÈü≥ÊâÄÊúâÂ£∞Èü≥',
        globalUnmute: 'ÂèñÊ∂àÊâÄÊúâÂ£∞Èü≥ÈùôÈü≥',
      },
      'Japanese': {
        text: 'ÁøªË®≥',
        description: '„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà',
        noText: 'ÁîªÂÉèÂÜÖ„Å´„ÉÜ„Ç≠„Çπ„Éà„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü',
        history: 'Â±•Ê≠¥',
        viewHistory: 'Â±•Ê≠¥„ÇíË°®Á§∫',
        accessingCamera: '„Ç´„É°„É©„Å´„Ç¢„ÇØ„Çª„Çπ„Åó„Å¶„ÅÑ„Åæ„Åô...',
        cameraReady: '„Ç´„É°„É©„ÅÆÊ∫ñÂÇô„Åå„Åß„Åç„Åæ„Åó„ÅüÔºÅ',
        cameraFailed: '„Ç´„É°„É©„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ',
        allowCamera: '„Ç´„É°„É©„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÇíË®±ÂèØ„Åó„Å¶„ÄÅ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
        noCamera: '„Åì„ÅÆ„Éá„Éê„Ç§„Çπ„Å´„Ç´„É°„É©„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ',
        notSupported: '„Åì„ÅÆ„Éñ„É©„Ç¶„Ç∂„Åß„ÅØ„Ç´„É°„É©„ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ',
        unknownError: '‰∏çÊòé„Å™„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ',
        switchingCamera: '„Ç´„É°„É©„ÇíÂàá„ÇäÊõø„Åà„Å¶„ÅÑ„Åæ„Åô...',
        analyzingImage: 'ÁîªÂÉè„ÇíÂàÜÊûê„Åó„Å¶„ÅÑ„Åæ„Åô...',
        analysisComplete: 'ÂàÜÊûê„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºÅ',
        connectionFailed: 'Êé•Á∂ö„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Çµ„Éº„Éê„Éº„ÅåÂÆüË°å„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        failedToProcess: 'ÁîªÂÉè„ÅÆÂá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü',
        processingIndicator: '„ÅÇ„Å™„Åü„ÅÆÁîªÂÉè„ÇíÂàÜÊûê„Åó„Å¶„ÅÑ„Åæ„Åô...',
        yourGlance: '„ÅÇ„Å™„Åü„ÅÆ‰∏ÄÁû•',
        previousCaptures: 'ÈÅéÂéª„ÅÆË°®Á§∫',
        clearAll: '„Åô„Åπ„Å¶„ÇØ„É™„Ç¢',
        deleteCaptureTitle: '„Åì„ÅÆ„Ç≠„É£„Éó„ÉÅ„É£„ÇíÂâäÈô§',
        back: 'Êàª„Çã',
        captureImageTitle: 'ÁîªÂÉè„Çí„Ç≠„É£„Éó„ÉÅ„É£',
        globalMute: '„Åô„Åπ„Å¶„ÅÆ„Çµ„Ç¶„É≥„Éâ„Çí„Éü„É•„Éº„Éà',
        globalUnmute: '„Åô„Åπ„Å¶„ÅÆ„Çµ„Ç¶„É≥„Éâ„ÅÆ„Éü„É•„Éº„Éà„ÇíËß£Èô§',
      },
      'Korean': {
        text: 'Î≤àÏó≠',
        description: 'Ïª®ÌÖçÏä§Ìä∏',
        noText: 'Ïù¥ÎØ∏ÏßÄÏóêÏÑú ÌÖçÏä§Ìä∏Í∞Ä Í∞êÏßÄÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§',
        history: 'Í∏∞Î°ù',
        viewHistory: 'Í∏∞Î°ù Î≥¥Í∏∞',
        accessingCamera: 'Ïπ¥Î©îÎùºÏóê Ïï°ÏÑ∏Ïä§ÌïòÎäî Ï§ë...',
        cameraReady: 'Ïπ¥Î©îÎùº Ï§ÄÎπÑ ÏôÑÎ£å!',
        cameraFailed: 'Ïπ¥Î©îÎùº Ïï°ÏÑ∏Ïä§Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ',
        allowCamera: 'Ïπ¥Î©îÎùº Ïï°ÏÑ∏Ïä§Î•º ÌóàÏö©ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌïòÏã≠ÏãúÏò§.',
        noCamera: 'Ïù¥ Í∏∞Í∏∞ÏóêÏÑú Ïπ¥Î©îÎùºÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.',
        notSupported: 'Ïù¥ Î∏åÎùºÏö∞Ï†ÄÏóêÏÑúÎäî Ïπ¥Î©îÎùºÍ∞Ä ÏßÄÏõêÎêòÏßÄ ÏïäÏäµÎãàÎã§.',
        unknownError: 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.',
        switchingCamera: 'Ïπ¥Î©îÎùº Ï†ÑÌôò Ï§ë...',
        analyzingImage: 'Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù Ï§ë...',
        analysisComplete: 'Î∂ÑÏÑù ÏôÑÎ£å!',
        failedToProcess: 'Ïù¥ÎØ∏ÏßÄ Ï≤òÎ¶¨ Ïã§Ìå®',
        connectionFailed: 'Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ÏÑúÎ≤ÑÍ∞Ä Ïã§Ìñâ Ï§ëÏù∏ÏßÄ ÌôïÏù∏ÌïòÏã≠ÏãúÏò§.',
        processingIndicator: 'Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù Ï§ë...',
        yourGlance: 'ÎãπÏã†Ïùò ÏãúÏÑ†',
        previousCaptures: 'Ïù¥Ï†Ñ Î∑∞',
        clearAll: 'Î™®Îëê ÏßÄÏö∞Í∏∞',
        deleteCaptureTitle: 'Ïù¥ Ï∫°Ï≤ò ÏÇ≠Ï†ú',
        back: 'Îí§Î°ú',
        captureImageTitle: 'Ïù¥ÎØ∏ÏßÄ Ï∫°Ï≤ò',
        globalMute: 'Î™®Îì† ÏÜåÎ¶¨ ÏùåÏÜåÍ±∞',
        globalUnmute: 'Î™®Îì† ÏÜåÎ¶¨ ÏùåÏÜåÍ±∞ Ìï¥Ï†ú',
      }
    };
    return labels[lang] || labels['English'];
  };

  const showStatus = (message, type = 'info') => {
    setStatus({ message, type });
  };

  const labels = getLabels(language);

  const showError = (message) => {
    setStatus({ message, type: 'error' });
  };

  const startCamera = async (facingMode = 'user') => {
    try {
      showStatus(labels.accessingCamera, 'info');
      
      // Stop any existing stream
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      
      const constraints = {
        video: {
          facingMode: facingMode,
          width: { ideal: 430 },
          height: { ideal: 932 }
        },
        audio: false
      };
      
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
      }
      
      setCurrentStream(stream);
      setCurrentFacingMode(facingMode);
      
      showStatus(labels.cameraReady, 'success');
      
      // Hide status after 2 seconds with fade-out animation
      setTimeout(() => {
        const statusElement = document.querySelector('.status-message');
        if (statusElement) {
          statusElement.classList.add('fade-out');
          // Clear the status after animation completes
          setTimeout(() => {
            setStatus({ message: '', type: 'info' });
          }, 300);
        }
      }, 2000);
      
    } catch (error) {
      console.error('Error accessing camera:', error);
      
      let errorMessage = labels.cameraFailed;
      
      if (error.name === 'NotAllowedError') {
        errorMessage += labels.allowCamera;
      } else if (error.name === 'NotFoundError') {
        errorMessage += labels.noCamera;
      } else if (error.name === 'NotSupportedError') {
        errorMessage += labels.notSupported;
      } else {
        errorMessage += error.message || labels.unknownError;
      }
      
      showError(errorMessage);
    }
  };

  const switchCamera = async () => {
    const newFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
    showStatus(labels.switchingCamera, 'info');
    await startCamera(newFacingMode);
  };

  const captureImage = () => {
    if (!videoRef.current || !canvasRef.current) return;

    // Add previous capture to history before taking new one
    if (currentCaptureData) {
      setCaptureHistory(prev => [currentCaptureData, ...prev]);
    }

    const video = videoRef.current;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    // Set canvas dimensions to match video
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    // Draw the current frame from video to canvas
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    // Convert canvas to base64 image
    const imageDataUrl = canvas.toDataURL('image/jpeg', 0.9);
    setCapturedImage(imageDataUrl);

    // Process the image
    processImage(imageDataUrl);
  };

  const processImage = async (imageDataUrl) => {
    setIsProcessing(true);
    setIsResultVisible(true);
    setResult(null);
    setProcessedResult(null);
    setProcessingError(null);
    showStatus(labels.analyzingImage, 'info');

    try {
      const response = await fetch('http://127.0.0.1:5051/process-image', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json', 
        },
        body: JSON.stringify({
          image: imageDataUrl,
          language: language
        })
      });

      const data = await response.json();

      if (data.success) {
        // Handle the JSON response format with translation and context
        const responseData = data.result || data;
        const resultData = { translation: '', description: '' };
        
        // Handle the nested structure with completion_message
        if (responseData && responseData.completion_message && responseData.completion_message.content) {
          const textContent = responseData.completion_message.content.text;
          
          try {
            // Remove markdown code block wrapper and parse JSON
            const jsonString = textContent.replace(/```json\n?|\n?```/g, '').trim();
            const parsedData = JSON.parse(jsonString);
            
            resultData.translation = parsedData.translation || '';
            resultData.description = parsedData.context || '';

          } catch (parseError) {
            resultData.translation = textContent; // Fallback to raw text
          }
        } else if (responseData && typeof responseData === 'object') {
          // Fallback for direct object structure
          resultData.translation = responseData.translation || '';
          resultData.description = responseData.context || '';

        } else if (typeof responseData === 'string') {
          resultData.translation = responseData;
        }

        setProcessedResult(resultData);
        setIsTtsOn(!isGloballyMuted);
        setProcessingError(null);
        
        // Store as current capture data (don't add to history yet)
        setCurrentCaptureData({
          id: Date.now(),
          image: imageDataUrl,
          result: resultData,
          language: language,
          timestamp: new Date().toLocaleString()
        });
        
        showStatus(labels.analysisComplete, 'success');
        
        // Auto-hide success status after 3 seconds with fade-out animation
        setTimeout(() => {
          const statusElement = document.querySelector('.status-message');
          if (statusElement) {
            statusElement.classList.add('fade-out');
            // Clear the status after animation completes
            setTimeout(() => {
              setStatus({ message: '', type: 'info' });
            }, 300);
          }
        }, 3000);
      } else {
        const errorMsg = data.error || labels.failedToProcess;
        setProcessingError(errorMsg);
        setProcessedResult(null);
        
        // Store failed capture as current data
        setCurrentCaptureData({
          id: Date.now(),
          image: imageDataUrl,
          result: null,
          error: errorMsg,
          language: language,
          timestamp: new Date().toLocaleString()
        });
        
        showError(errorMsg);
      }
    } catch (error) {
      console.error('Error processing image:', error);
      const errorMsg = labels.connectionFailed;
      setProcessingError(errorMsg);
      setProcessedResult(null);
      
      // Store failed capture as current data
      setCurrentCaptureData({
        id: Date.now(),
        image: imageDataUrl,
        result: null,
        error: errorMsg,
        language: language,
        timestamp: new Date().toLocaleString()
      });
      
      showError(errorMsg);
    } finally {
      setIsProcessing(false);
    }
  };

  // Handle touch events for the result container
  const handleTouchStart = useCallback((e) => {
    const touch = e.touches[0];
    const container = resultContainerRef.current;
    if (container) {
      container.dataset.touchStart = touch.clientY;
      container.dataset.scrollTop = container.scrollTop;
    }
  }, []);

  const handleTouchMove = useCallback((e) => {
    const container = resultContainerRef.current;
    if (!container || !container.dataset.touchStart) return;

    const touch = e.touches[0];
    const startY = parseInt(container.dataset.touchStart);
    const scrollTop = parseInt(container.dataset.scrollTop);
    const diff = touch.clientY - startY;
    const threshold = window.innerHeight * 0.25; // 25vh

    // If scrolled to top and pulling down, prevent default scroll
    if (scrollTop <= 0 && diff > 0) {
      e.preventDefault();
      
      // If we've reached the threshold while dragging, trigger close animation
      if (diff > threshold && !container.dataset.closing) {
        container.dataset.closing = 'true';
        container.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        container.style.transform = 'translateY(100%)';
        
        // Clean up and hide after animation
        setTimeout(() => {
          setIsResultVisible(false);
          container.style.transform = '';
          container.style.transition = '';
          delete container.dataset.closing;
          delete container.dataset.touchStart;
          delete container.dataset.scrollTop;
        }, 300);
      } else if (!container.dataset.closing) {
        // Continue normal drag if not closing
        container.style.transform = `translateY(${Math.min(diff, 200)}px)`;
      }
    }
  }, []);

  const handleTouchEnd = useCallback((e) => {
    const container = resultContainerRef.current;
    if (!container) return;

    // If already closing, don't interfere
    if (container.dataset.closing) return;

    const transform = container.style.transform;
    const translateY = transform ? parseInt(transform.replace('translateY(', '')) : 0;
    const threshold = window.innerHeight * 0.25; // 25vh

    // Restore transition for smooth animation
    container.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';

    // If pulled down more than threshold, hide the result
    if (translateY > threshold) {
      // Animate to fully closed position first
      container.style.transform = 'translateY(100%)';
      // Then hide after animation completes
      setTimeout(() => {
        setIsResultVisible(false);
        container.style.transform = '';
        container.style.transition = '';
      }, 300);
    } else {
      // Reset transform if not closing
      container.style.transform = '';
      // Clean up after animation
      setTimeout(() => {
        container.style.transition = '';
      }, 300);
    }

    delete container.dataset.touchStart;
    delete container.dataset.scrollTop;
  }, []);

  // Handle mouse events for desktop dragging
  const handleMouseDown = useCallback((e) => {
    // Only handle mouse down on the drag handle area or top of modal
    const target = e.target;
    const container = resultContainerRef.current;
    
    if (!container) return;
    
    // Check if click is on the drag handle or top area of modal
    const rect = container.getBoundingClientRect();
    const clickY = e.clientY;
    const modalTop = rect.top;
    
    // Only allow dragging if clicking within 60px of the top of the modal
    if (clickY - modalTop > 60) return;
    
    e.preventDefault();
    container.dataset.mouseStart = e.clientY;
    container.dataset.scrollTop = container.scrollTop;
    container.style.userSelect = 'none'; // Prevent text selection while dragging
    
    // Add global mouse event listeners
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, []);

  const handleMouseMove = useCallback((e) => {
    const container = resultContainerRef.current;
    if (!container || !container.dataset.mouseStart) return;

    const startY = parseInt(container.dataset.mouseStart);
    const scrollTop = parseInt(container.dataset.scrollTop);
    const diff = e.clientY - startY;
    const threshold = window.innerHeight * 0.25; // 25vh

    // If scrolled to top and pulling down, allow dragging
    if (scrollTop <= 0 && diff > 0) {
      e.preventDefault();
      
      // If we've reached the threshold while dragging, trigger close animation
      if (diff > threshold && !container.dataset.closing) {
        container.dataset.closing = 'true';
        container.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        container.style.transform = 'translateY(100%)';
        container.style.userSelect = '';
        
        // Remove global listeners
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        
        // Clean up and hide after animation
        setTimeout(() => {
          setIsResultVisible(false);
          container.style.transform = '';
          container.style.transition = '';
          delete container.dataset.closing;
          delete container.dataset.mouseStart;
          delete container.dataset.scrollTop;
        }, 300);
      } else if (!container.dataset.closing) {
        // Continue normal drag if not closing
        container.style.transform = `translateY(${Math.min(diff, 200)}px)`;
        container.style.transition = 'none'; // Disable transition during drag
      }
    }
  }, []);

  const handleMouseUp = useCallback((e) => {
    const container = resultContainerRef.current;
    if (!container) return;

    // Remove global listeners
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);

    // If already closing, don't interfere
    if (container.dataset.closing) return;

    const transform = container.style.transform;
    const translateY = transform ? parseInt(transform.replace('translateY(', '')) : 0;
    const threshold = window.innerHeight * 0.25; // 25vh

    // Restore transition for smooth animation
    container.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
    container.style.userSelect = '';

    // If pulled down more than threshold, hide the result
    if (translateY > threshold) {
      // Animate to fully closed position first
      container.style.transform = 'translateY(100%)';
      // Then hide after animation completes
      setTimeout(() => {
        setIsResultVisible(false);
        container.style.transform = '';
        container.style.transition = '';
      }, 300);
    } else {
      // Reset transform if not closing
      container.style.transform = '';
      // Clean up after animation
      setTimeout(() => {
        container.style.transition = '';
      }, 300);
    }

    delete container.dataset.mouseStart;
    delete container.dataset.scrollTop;
  }, []);

  const clearHistory = () => {
    setCaptureHistory([]);
    setCurrentCaptureData(null);
    // Add smooth closing animation
    const container = resultContainerRef.current;
    if (container) {
      container.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      container.style.transform = 'translateY(100%)';
      setTimeout(() => {
        setIsResultVisible(false);
        container.style.transform = '';
        container.style.transition = '';
      }, 300);
    } else {
      setIsResultVisible(false);
    }
  };

  const deleteHistoryItem = (id) => {
    setCaptureHistory(prev => prev.filter(item => item.id !== id));
  };

  const openHistory = () => {
    if (currentCaptureData || captureHistory.length > 0) {
      setIsResultVisible(true);
    }
  };

  const closeResultContainer = () => {
    // Add smooth closing animation
    const container = resultContainerRef.current;
    if (container) {
      container.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      container.style.transform = 'translateY(100%)';
      setTimeout(() => {
        setIsResultVisible(false);
        container.style.transform = '';
        container.style.transition = '';
      }, 300);
    } else {
      setIsResultVisible(false);
    }
  };

  // Text-to-speech function
  const handleTextToSpeech = async (text) => {
    setIsTtsLoading(true);
    setTtsAudioUrl(null);
    try {
      const response = await fetch('http://127.0.0.1:5051/text-to-speech', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text, voice: 'alloy' })
      });
      if (!response.ok) throw new Error('TTS failed');
      const blob = await response.blob();
      const url = URL.createObjectURL(blob);
      setTtsAudioUrl(url);
    } catch (err) {
      alert('Text-to-speech failed.');
    } finally {
      setIsTtsLoading(false);
    }
  };

  const handleTtsToggle = () => {
    const isNowOn = !isTtsOn;
    setIsTtsOn(isNowOn);

    if (isNowOn) {
      // If turning on and there's a result, fetch the audio to play.
      if (processedResult && !ttsAudioUrl) {
        const { description, translation } = processedResult;
        let textToSpeak = description || '';

        if (!textToSpeak) {
          textToSpeak = translation || '';
        }

        if (textToSpeak) {
          handleTextToSpeech(textToSpeak);
        }
      }
    } else {
      // If turning off, stop any playing audio.
      if (audioRef.current) {
        audioRef.current.pause();
      }
      setTtsAudioUrl(null);
    }
  };

  useEffect(() => {
    // Check if camera is supported
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      showError('Camera access not supported. Please use a modern browser.');
      return;
    }

    // Auto-start camera when component mounts
    startCamera();

    // Clean up when component unmounts
    return () => {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
    };
  }, []); // Empty dependency array to run only on mount

  useEffect(() => {
    // Auto-play TTS when a new result comes in and TTS is enabled
    if (processedResult && isTtsOn) {
      const { description, translation } = processedResult;
      let textToSpeak = description || '';

      if (!textToSpeak) {
        textToSpeak = translation || '';
      }

      if (textToSpeak) {
        handleTextToSpeech(textToSpeak);
      }
    }
  }, [processedResult]); // Intentionally only run when processedResult changes

  useEffect(() => {
    // Show result container when there's a current result or history
    if (processedResult || processingError || captureHistory.length > 0) {
      setIsResultVisible(true);
    }
  }, [processedResult, processingError, captureHistory]);

  // Handle touch events with proper passive/non-passive settings
  useEffect(() => {
    const container = resultContainerRef.current;
    if (!container) return;

    // Add touch event listeners with non-passive option
    container.addEventListener('touchstart', handleTouchStart, { passive: false });
    container.addEventListener('touchmove', handleTouchMove, { passive: false });
    container.addEventListener('touchend', handleTouchEnd, { passive: false });

    // Cleanup function
    return () => {
      container.removeEventListener('touchstart', handleTouchStart);
      container.removeEventListener('touchmove', handleTouchMove);
      container.removeEventListener('touchend', handleTouchEnd);
    };
  }, [handleTouchStart, handleTouchMove, handleTouchEnd, isResultVisible]);

  return (
    <div className="camera-feed">
      <div className="options">
        <select
          value={language}
          onChange={(e) => setLanguage(e.target.value)}
        >
          <option value="English">üá∫üá∏ English</option>
          <option value="Spanish">üá™üá∏ Spanish</option>
          <option value="French">üá´üá∑ French</option>
          <option value="German">üá©üá™ German</option>
          <option value="Italian">üáÆüáπ Italian</option>
          <option value="Portuguese">üáµüáπ Portuguese</option>
          <option value="Chinese">üá®üá≥ Chinese</option>
          <option value="Japanese">üáØüáµ Japanese</option>
          <option value="Korean">üá∞üá∑ Korean</option>
        </select>

          <button 
            onClick={openHistory}
            className="history-btn"
          title={labels.viewHistory}
          >
          {labels.history}
          {((currentCaptureData ? 1 : 0) + captureHistory.length > 0) && ` ‚ü≤ ${(currentCaptureData ? 1 : 0) + captureHistory.length}`}
          </button>
      </div>

      {status.message && (
        <div className="status-message" data-type={status.type}>
          {status.message}
        </div>
      )}

      <div className="video-container">
        <video
          ref={videoRef}
          autoPlay
          playsInline
          muted
          style={{ transform: currentFacingMode === 'user' ? 'scaleX(-1)' : 'none' }}
        />
        <canvas ref={canvasRef} style={{ display: 'none' }} />
      </div>

      <div className="controls">
        <button 
          onClick={captureImage} 
          disabled={isProcessing}
          className={`capture-btn ${isProcessing ? 'processing' : ''}`}
          title={labels.captureImageTitle}
        >
        </button>
        <button
          onClick={() => setIsGloballyMuted(!isGloballyMuted)}
          className="control-icon-btn"
          title={isGloballyMuted ? labels.globalUnmute : labels.globalMute}
        >
          {isGloballyMuted ? 'üîá' : 'üîä'}
        </button>
      </div>

      {(processedResult || processingError || isProcessing || captureHistory.length > 0) && isResultVisible && (
        <>
          {/* Backdrop overlay */}
          <div 
            className="backdrop-overlay"
            onClick={closeResultContainer}
          />
          
          <div 
            ref={resultContainerRef}
            className={`result-container ${!isResultVisible ? 'hidden' : ''}`}
            onMouseDown={handleMouseDown}
          >
            {/* Current/Latest Capture */}
            {(capturedImage || isProcessing || processedResult || processingError) && (
              <div className="current-capture">
                {capturedImage && (
                  <img
                    src={capturedImage}
                    alt="Latest Capture"
                    onClick={() => setLightboxData(currentCaptureData)}
                  />
                )}
                
                {isProcessing && (
                  <div className="processing-indicator">
                    {labels.processingIndicator}
                  </div>
                )}
                
                {processingError && (
                  <div className="error-message">
                    ‚ùå {processingError}
                  </div>
                )}
                
                {processedResult && (
                  <div className="llama-response">
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                      <h3 style={{ margin: 0, fontSize: '17px', fontWeight: '600' }}>üåê {labels.yourGlance}</h3>
                              <button
                        onClick={handleTtsToggle}
                                disabled={isTtsLoading}
                        className="tts-toggle-btn"
                        style={{
                          background: 'rgba(0, 122, 255, 0.1)',
                          color: '#007aff',
                          border: '1px solid rgba(0, 122, 255, 0.2)',
                          borderRadius: '50%',
                          width: '40px',
                          height: '40px',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          cursor: 'pointer',
                          transition: 'all 0.2s ease',
                        }}
                      >
                        {isTtsLoading
                          ? '...'
                          : !isTtsOn
                            ? 'üîá'
                            : 'üîä'}
                              </button>
                                </div>
                    <p style={{ whiteSpace: 'pre-line' }}>
                      {(() => {
                        const { translation, description } = processedResult;
                        const parts = [];
                        parts.push(`${labels.text}: ${translation || labels.noText}`);
                        if (description) {
                          parts.push(`${labels.description}: ${description}`);
                        }
                        return parts.join('\n\n');
                      })()}
                    </p>
                    {ttsAudioUrl && (
                      <audio
                        ref={audioRef}
                        src={ttsAudioUrl}
                        autoPlay={isTtsOn}
                        onEnded={() => {
                          setTtsAudioUrl(null); // Clear URL after playing
                          setIsTtsOn(false); // Turn off after playing
                        }}
                      />
                    )}
                  </div>
                )}
              </div>
            )}

            {/* History Section */}
            {captureHistory.length > 0 && (
              <div className="history-section">
                <div className="history-header">
                  <h3>{labels.previousCaptures}</h3>
                  <button onClick={clearHistory} className="clear-history-btn">
                    üóëÔ∏è {labels.clearAll}
                  </button>
                </div>
                
                <div className="history-list">
                  {captureHistory.map((item) => (
                    <div key={item.id} className="history-item">
                      <div className="history-item-header">
                        <span className="history-timestamp">{item.timestamp}</span>
                        <button 
                          onClick={() => deleteHistoryItem(item.id)}
                          className="delete-item-btn"
                          title="Delete this capture"
                        >
                          ‚úï
                        </button>
                      </div>
                      
                      <img
                        src={item.image}
                        alt={`Capture from ${item.timestamp}`}
                        onClick={() => setLightboxData(item)}
                      />
                      
                      <div className="history-meta">
                        <span className="history-language">
                          {item.language === 'English' ? 'üá∫üá∏' : 
                           item.language === 'Spanish' ? 'üá™üá∏' :
                           item.language === 'French' ? 'üá´üá∑' :
                           item.language === 'German' ? 'üá©üá™' :
                           item.language === 'Italian' ? 'üáÆüáπ' :
                           item.language === 'Portuguese' ? 'üáµüáπ' :
                           item.language === 'Chinese' ? 'üá®üá≥' :
                           item.language === 'Japanese' ? 'üáØüáµ' :
                           item.language === 'Korean' ? 'üá∞üá∑' : 'üåê'} {item.language}
                        </span>
                      </div>
                      
                      {item.result && (
                        <div className="history-result">
                          <p>{(() => {
                            const historyLabels = getLabels(item.language);
                            const { translation, description } = item.result;
                            const parts = [];
                            parts.push(`${historyLabels.text}: ${translation || historyLabels.noText}`);
                            if (description) {
                              parts.push(`${historyLabels.description}: ${description}`);
                            }
                            return parts.join('\n\n');
                          })()}</p>
                        </div>
                      )}
                      
                      {item.error && (
                        <div className="history-error">
                          ‚ùå {item.error}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </>
      )}
      {lightboxData && (
        <div className="lightbox-overlay" onClick={() => setLightboxData(null)}>
          <div className="lightbox-content" onClick={(e) => e.stopPropagation()}>
            <div className="lightbox-header">
              <button onClick={() => setLightboxData(null)} className="back-button">
                {labels.back}
              </button>
            </div>
            <img src={lightboxData.image} alt="Enlarged capture" className="lightbox-image" />
            {lightboxData.result && (
              <div className="lightbox-details">
                <p>{(() => {
                  const lightboxLabels = getLabels(lightboxData.language);
                  const { translation, description } = lightboxData.result;
                  const parts = [];
                  parts.push(`${lightboxLabels.text}: ${translation || lightboxLabels.noText}`);
                  if (description) {
                    parts.push(`${lightboxLabels.description}: ${description}`);
                  }
                  return parts.join('\n\n');
                })()}</p>
              </div>
            )}
            {lightboxData.error && (
              <div className="lightbox-details error-message">
                ‚ùå {lightboxData.error}
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default CameraFeed;